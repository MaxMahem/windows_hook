use fluent_result::{IntoOption, IntoResult};

use crate::{module::Module, *};

/// A safe wrapper around [winsafe::HHOOK] that automatically unsets itself on drop.
/// The hook is set once at construction and can be manually unset any number of times without error.
/// If manually unset, drop becomes a no-op.
///
/// If feature `tracing` is enabled, a trace message will be emitted if there is an error when the
/// hook is dropped.
///
/// # Examples
///
/// The passthrough method here is reused in other examples.
/// ```rust
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// use windows_hook::{WindowsHook, WH, Handle, HHOOK, ThreadId, Module};
///
/// extern "system" fn passthrough(code: i32, wparam: usize, lparam: isize) -> isize {
///     // simple pass through
///     HHOOK::NULL.CallNextHookEx(unsafe { WH::from_raw(code) }, wparam, lparam)
/// }
///
/// let hook = WindowsHook::set_new(WH::KEYBOARD_LL, passthrough, Module::NULL, ThreadId::NONE)?;
///
/// assert!(hook.state().is_set());
///
/// // do stuff
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Default)]
pub struct WindowsHook {
    hook: Option<HHOOK>,
}

/// The state of the hook.
#[derive(Debug, derive_more::IsVariant)]
pub enum HookState {
    /// The hook is set.
    Set,
    /// The hook is unset.
    Unset,
}

impl WindowsHook {
    /// Creates a new [`WindowsHook`] and sets it.
    ///
    /// # Parameters
    ///
    /// - `id`: The hook type id.
    /// - `proc`: The callback proccess connected to the hook.
    /// - `module`: A [`Module`] for the hook, or an object that can be converted to a [`Module`]
    ///   (such as an [`HINSTANCE`]). For `null` hooks, [Module::NULL] can be used.
    /// - `thread_id`: A [`ThreadId`] for the hook, or an object that can be converted to a
    ///   [`ThreadId`] (such as a [`u32`]). For threadless hooks, [`ThreadId::NONE`] can be used.
    ///
    /// # Errors
    ///
    /// Returns any error generated by the os during `SetWindowsHookEx`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::{WindowsHook, WH, ThreadId, Module};
    /// # use windows_hook::{Handle, HHOOK};
    /// # extern "system" fn your_hook_fn(code: i32, wparam: usize, lparam: isize) -> isize {
    /// #   HHOOK::NULL.CallNextHookEx(unsafe { WH::from_raw(code) }, wparam, lparam)
    /// # }
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// let hook = WindowsHook::set_new(WH::KEYBOARD_LL, your_hook_fn, Module::NULL, ThreadId::NONE)?;
    ///
    /// assert!(hook.state().is_set());
    /// # Ok(())
    /// # }
    /// ```
    pub fn set_new<Mod, Tid>(
        id: WH,
        proc: HOOKPROC,
        module: Mod,
        thread_id: Tid,
    ) -> Result<Self, SysError>
    where
        Mod: Into<Module>,
        Tid: Into<ThreadId>,
    {
        Self {
            hook: HHOOK::SetWindowsHookEx(
                id,
                proc,
                module.into().as_HINSTANCE().as_ref(),
                thread_id.into().as_raw_option(),
            )?
            .into_some(),
        }
        .into_ok()
    }

    /// Unsets a windows hook. Returns the perviously set hook state.
    ///
    /// # Errors
    ///
    /// Returns any error generated by the os during `UnhookWindowsHookEx`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::{WindowsHook, WH, ThreadId, Module};
    /// # use windows_hook::{Handle, HHOOK};
    /// # extern "system" fn your_hook_fn(code: i32, wparam: usize, lparam: isize) -> isize {
    /// #   HHOOK::NULL.CallNextHookEx(unsafe { WH::from_raw(code) }, wparam, lparam)
    /// # }
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// let mut hook = WindowsHook::set_new(WH::KEYBOARD_LL, your_hook_fn, Module::NULL, ThreadId::NONE)?;
    /// let was_set = hook.unset()?;
    ///
    /// assert!(hook.state().is_unset());
    /// assert!(was_set.is_set());
    /// # Ok(())
    /// # }
    /// ```
    pub fn unset(&mut self) -> Result<HookState, SysError> {
        match self.hook.take() {
            None => Ok(HookState::Unset),
            Some(mut hook) => {
                hook.UnhookWindowsHookEx()?;
                Ok(HookState::Set)
            }
        }
    }

    /// Returns the state of the hook.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::{WindowsHook, WH, ThreadId, Module};
    /// # use windows_hook::{Handle, HHOOK};
    /// # extern "system" fn your_hook_fn(code: i32, wparam: usize, lparam: isize) -> isize {
    /// #   HHOOK::NULL.CallNextHookEx(unsafe { WH::from_raw(code) }, wparam, lparam)
    /// # }
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// let mut hook = WindowsHook::set_new(WH::KEYBOARD_LL, your_hook_fn, Module::NULL, ThreadId::NONE)?;
    /// assert!(hook.state().is_set());
    ///
    /// hook.unset()?;
    /// assert!(hook.state().is_unset());
    ///
    /// # Ok(())
    /// # }
    /// ```
    pub fn state(&self) -> HookState {
        match self.hook {
            None => HookState::Unset,
            Some(_) => HookState::Set,
        }
    }
}

impl Drop for WindowsHook {
    fn drop(&mut self) {
        #[allow(unused_variables)]
        let result = self.unset();

        #[cfg(feature = "tracing")]
        match result {
            Ok(_) => (),
            Err(err) => tracing::error!(hook_id = self.id, err, "failed to unset hook"),
        }
    }
}

/// A safe wrapper around a [HHOOK] for a the [WH::KEYBOARD_LL] keyboard hook.
///
/// # Examples
///
/// ```rust
/// use windows_hook::KeyboardLLHook;
/// # use windows_hook::{WindowsHook, WH, Handle, HHOOK};
/// # extern "system" fn your_hook_fn(code: i32, wparam: usize, lparam: isize) -> isize {
/// #   HHOOK::NULL.CallNextHookEx(unsafe { WH::from_raw(code) }, wparam, lparam)
/// # }
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let hook = KeyboardLLHook::set_new(your_hook_fn)?;
///
/// assert!(hook.state().is_set());
///
/// // do stuff
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Default, derive_more::Deref, derive_more::DerefMut)]
pub struct KeyboardLLHook(WindowsHook);

impl KeyboardLLHook {
    /// Creates a new [KeyboardLLHook] and sets it.
    ///
    /// # Errors
    ///
    /// Returns any error generated by the os during `SetWindowsHookEx`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::KeyboardLLHook;
    /// # use windows_hook::{WH, Handle, HHOOK};
    /// # extern "system" fn your_hook_fn(code: i32, wparam: usize, lparam: isize) -> isize {
    /// #   HHOOK::NULL.CallNextHookEx(unsafe { WH::from_raw(code) }, wparam, lparam)
    /// # }
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// let hook = KeyboardLLHook::set_new(your_hook_fn)?;
    ///
    /// assert!(hook.state().is_set());
    /// # Ok(())
    /// # }
    /// ```
    pub fn set_new(proc: HOOKPROC) -> Result<Self, SysError> {
        WindowsHook::set_new(WH::KEYBOARD_LL, proc, Module::NULL, ThreadId::NONE).map(Self)
    }
}

/// A safe wrapper around a [HHOOK] for a the [WH::MOUSE_LL] mouse hook.
///
/// # Examples
///
/// ```rust
/// use windows_hook::MouseLLHook;
/// # use windows_hook::{WH, Handle, HHOOK};
/// # extern "system" fn your_hook_fn(code: i32, wparam: usize, lparam: isize) -> isize {
/// #   HHOOK::NULL.CallNextHookEx(unsafe { WH::from_raw(code) }, wparam, lparam)
/// # }
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let hook = MouseLLHook::set_new(your_hook_fn)?;
///
/// assert!(hook.state().is_set());
///
/// // do stuff
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Default, derive_more::Deref, derive_more::DerefMut)]
pub struct MouseLLHook(WindowsHook);

impl MouseLLHook {
    /// Creates a new [MouseLLHook] and sets it.
    ///
    /// # Errors
    ///
    /// Returns any error generated by the os during `SetWindowsHookEx`.
    pub fn set_new(proc: HOOKPROC) -> Result<Self, SysError> {
        WindowsHook::set_new(WH::MOUSE_LL, proc, Module::NULL, ThreadId::NONE).map(Self)
    }
}
