use std::ffi::c_void;
use std::ptr::NonNull;

use fluent_result::into::IntoOption;
use tap::Pipe;

use crate::{HINSTANCE, Handle, SysError};

/// A module handle.
///
/// This is a wrapper around [`Option<NonNull<c_void>>`](NonNull), where a [`None`] value represents
/// no module handle, or `NULL`. This type is similar in concept to [`Option<HINSTANCE>`](HINSTANCE)
/// but uses [`NonNull`] size optimisation.
///
/// # Examples
///
/// ```rust
/// use windows_hook::Module;
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
///
/// let module = Module::current()?;
/// assert!(!module.is_null());
/// # Ok(())
/// # }
/// ```
#[derive(
    Clone,
    Copy,
    Hash,
    PartialEq,
    Eq,
    derive_more::Deref,
    derive_more::Display,
    derive_more::LowerHex,
    derive_more::UpperHex,
)]
#[display("{:#010x}", self.ptr() as usize)]
#[lower_hex("{:#010x}", self.ptr() as usize)]
#[upper_hex("{:#010X}", self.ptr() as usize)]
pub struct Module(Option<NonNull<c_void>>);

impl Module {
    /// A null module handle.
    pub const NULL: Self = Self(None);

    /// Returns the current module handle using `GetModuleHandleW(NULL)`.
    ///
    /// # Errors
    ///
    /// Returns any error generated by the os during `GetModuleHandleW`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::Module;
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// let module = Module::current()?;
    /// assert!(!module.is_null());
    /// # Ok(())
    /// # }
    /// ```
    pub fn current() -> Result<Self, SysError> {
        HINSTANCE::GetModuleHandle(None).map(Module::from)
    }

    /// Returns the module handle for the given module name using `GetModuleHandleW`.
    ///
    /// # Errors
    ///
    /// Returns any error generated by the os during `GetModuleHandleW`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::Module;
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// let module = Module::get_by_name("kernel32.dll")?;
    /// assert!(!module.is_null());
    /// # Ok(())
    /// # }
    /// ```
    pub fn get_by_name<S: AsRef<str>>(module_name: S) -> Result<Self, SysError> {
        module_name
            .as_ref()
            .into_some()
            .pipe(HINSTANCE::GetModuleHandle)
            .map(Module::from)
    }

    /// Returns `true` if the handle is null, `false` otherwise.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::Module;
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// assert_eq!(true, Module::NULL.is_null());
    /// assert_eq!(false, Module::current()?.is_null());
    /// # Ok(())
    /// # }
    /// ```
    #[inline]
    #[must_use]
    pub fn is_null(&self) -> bool {
        self.0.is_none()
    }

    /// Returns `true` if the handle is invalid, `false` otherwise.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::{Module, Handle};
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// assert_eq!(true, Module::INVALID.is_invalid());
    /// assert_eq!(false, Module::NULL.is_invalid());
    /// assert_eq!(false, Module::current()?.is_invalid());
    /// # Ok(())
    /// # }
    /// ```
    #[inline]
    #[must_use]
    pub fn is_invalid(&self) -> bool {
        self == &Self::INVALID
    }

    /// Returns the handle as a [`Option<HINSTANCE>`](HINSTANCE), where a [None] value means a null
    /// handle.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::{Module, HINSTANCE};
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// assert!(Module::NULL.as_HINSTANCE().is_none());
    /// assert!(Module::current()?.as_HINSTANCE().is_some());
    /// # Ok(())
    /// # }
    /// ```
    #[allow(non_snake_case)]
    pub fn as_HINSTANCE(&self) -> Option<HINSTANCE> {
        self.0
            .map(NonNull::as_ptr)
            // SAFETY: We never touch the pointer so its as safe as it ever was.
            .map(|nn| unsafe { HINSTANCE::from_ptr(nn) })
    }
}

impl From<HINSTANCE> for Module {
    fn from(handle: HINSTANCE) -> Self {
        handle.ptr().pipe(NonNull::new).pipe(Self)
    }
}

impl std::fmt::Debug for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ptr = self.ptr() as usize;
        write!(f, "[{ptr:#010x} {ptr}] Module")
    }
}

unsafe impl Send for Module {}

impl Handle for Module {
    const NULL: Self = Self(None);
    const INVALID: Self = Self(NonNull::new(-1isize as *mut c_void));

    unsafe fn from_ptr(p: *mut std::ffi::c_void) -> Self {
        NonNull::new(p).pipe(Self)
    }

    unsafe fn as_mut(&mut self) -> &mut *mut c_void {
        // SAFETY: We never touch the pointer so its as safe as it ever was.
        // Transmute is safe because `NonNull` just wraps `*mut c_void`.
        unsafe { &mut *std::ptr::from_mut(self).cast::<*mut c_void>() }
    }

    fn ptr(&self) -> *mut std::ffi::c_void {
        self.0.map_or(std::ptr::null_mut(), NonNull::as_ptr)
    }
}
