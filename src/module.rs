use std::ffi::c_void;
use std::ptr::NonNull;

use fluent_result::IntoOption;
use tap::Pipe;

use crate::{HINSTANCE, Handle, SysError};

/// A module handle.
///
/// This is a wrapper around [`Option<NonNull<c_void>>`](NonNull), where a [None] value represents
/// no module handle, or `NULL`. This type is similar in concept to [`Option<HINSTANCE>`](HINSTANCE).
///
/// # Examples
///
/// ```rust
/// use windows_hook::Module;
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
///
/// let module = Module::current()?;
/// assert!(!module.is_null());
/// # Ok(())
/// # }
/// ```
#[derive(Clone, Copy, Hash, PartialEq, Eq, derive_more::Deref)]
pub struct Module(Option<NonNull<c_void>>);

impl Module {
    /// A null module handle.
    pub const NULL: Self = Self(None);

    /// Returns the current module handle using `GetModuleHandleW(NULL)`.
    ///
    /// # Errors
    ///
    /// Returns any error generated by the os during `GetModuleHandleW`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::Module;
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// let module = Module::current()?;
    /// assert!(!module.is_null());
    /// # Ok(())
    /// # }
    /// ```
    pub fn current() -> Result<Self, SysError> {
        HINSTANCE::GetModuleHandle(None).map(Module::from)
    }

    /// Returns the module handle for the given module name using `GetModuleHandleW`.
    ///
    /// # Errors
    ///
    /// Returns any error generated by the os during `GetModuleHandleW`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::Module;
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// let module = Module::get_by_name("kernel32.dll")?;
    /// assert!(!module.is_null());
    /// # Ok(())
    /// # }
    /// ```
    pub fn get_by_name<S: AsRef<str>>(module_name: S) -> Result<Self, SysError> {
        module_name
            .as_ref()
            .into_some()
            .pipe(HINSTANCE::GetModuleHandle)
            .map(Module::from)
    }

    /// Returns `true` if the handle is null, `false` otherwise.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::Module;
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// assert_eq!(true, Module::NULL.is_null());
    /// assert_eq!(false, Module::current()?.is_null());
    /// # Ok(())
    /// # }
    /// ```
    pub fn is_null(&self) -> bool {
        self.0.is_none()
    }

    /// Returns `true` if the handle is invalid, `false` otherwise.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::{Module, Handle};
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// assert_eq!(true, Module::INVALID.is_invalid());
    /// assert_eq!(false, Module::NULL.is_invalid());
    /// assert_eq!(false, Module::current()?.is_invalid());
    /// # Ok(())
    /// # }
    /// ```
    pub fn is_invalid(&self) -> bool {
        self == &Self::INVALID
    }

    /// Returns the handle as a [`Option<HINSTANCE>`](HINSTANCE), where a [None] value means a null
    /// handle.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use windows_hook::{Module, HINSTANCE};
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///
    /// assert!(Module::NULL.as_HINSTANCE().is_none());
    /// assert!(Module::current()?.as_HINSTANCE().is_some());
    /// # Ok(())
    /// # }
    /// ```
    #[allow(non_snake_case)]
    pub fn as_HINSTANCE(&self) -> Option<HINSTANCE> {
        self.0
            .map(NonNull::as_ptr)
            // SAFETY: We never touch the pointer so its as safe as it ever was.
            .map(|nn| unsafe { HINSTANCE::from_ptr(nn) })
    }
}

impl From<HINSTANCE> for Module {
    fn from(handle: HINSTANCE) -> Self {
        handle.ptr().pipe(NonNull::new).pipe(Self)
    }
}

impl std::fmt::Debug for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ptr = self.ptr() as usize;
        write!(f, "[{:#010x} {}] Module", ptr, ptr)
    }
}

impl std::fmt::Display for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:#010x}", self.ptr() as usize)
    }
}

impl std::fmt::LowerHex for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self.ptr() as usize).fmt(f)
    }
}

impl std::fmt::UpperHex for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self.ptr() as usize).fmt(f)
    }
}

unsafe impl Send for Module {}

impl Handle for Module {
    const NULL: Self = Self(None);
    const INVALID: Self = Self(NonNull::new(-1isize as *mut c_void));

    unsafe fn from_ptr(p: *mut std::ffi::c_void) -> Self {
        NonNull::new(p).pipe(Self)
    }

    unsafe fn as_mut(&mut self) -> &mut *mut c_void {
        // SAFETY: We never touch the pointer so its as safe as it ever was.
        // Transmute is safe because `NonNull` just wraps `*mut c_void`.
        unsafe { std::mem::transmute(self) }
    }

    fn ptr(&self) -> *mut std::ffi::c_void {
        self.0.map(NonNull::as_ptr).unwrap_or(std::ptr::null_mut())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[allow(non_snake_case)]
    fn test_module_from_HINSTANCE() -> Result<(), SysError> {
        let module = Module::from(HINSTANCE::NULL);
        assert!(module.is_null());

        let module: Module = HINSTANCE::GetModuleHandle(None)?.into();
        assert!(!module.is_null());

        Ok(())
    }

    #[test]
    fn test_module_from_ptr() -> Result<(), SysError> {
        let module = unsafe { Module::from_ptr(std::ptr::null_mut()) };
        assert!(module.is_null());

        let instance = HINSTANCE::GetModuleHandle(None)?;
        let module = unsafe { Module::from_ptr(instance.ptr()) };

        assert!(!module.is_null());
        assert_eq!(instance.ptr(), module.ptr());

        Ok(())
    }

    #[test]
    fn test_module_debug() -> Result<(), SysError> {
        let module = Module::current()?;
        let hinstance = HINSTANCE::GetModuleHandle(None)?;

        assert_eq!(format!("{:?}", module), format!("{:?}", hinstance));
        Ok(())
    }

    #[test]
    fn test_module_display() -> Result<(), SysError> {
        let module = Module::current()?;
        let hinstance = HINSTANCE::GetModuleHandle(None)?;

        assert_eq!(format!("{}", module), format!("{}", hinstance));
        Ok(())
    }

    #[test]
    fn test_module_lower_hex() -> Result<(), SysError> {
        let module = Module::current()?;
        let hinstance = HINSTANCE::GetModuleHandle(None)?;

        assert_eq!(format!("{:x}", module), format!("{:x}", hinstance));
        Ok(())
    }

    #[test]
    fn test_module_upper_hex() -> Result<(), SysError> {
        let module = Module::current()?;
        let hinstance = HINSTANCE::GetModuleHandle(None)?;

        assert_eq!(format!("{:X}", module), format!("{:X}", hinstance));
        Ok(())
    }
}
